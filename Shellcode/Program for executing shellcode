#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <errno.h>

static void croak(const char* msg) {
  fprintf("stsderr, "%s\n", msg);
  fflush(stderr);
}

static void usage(const char* prog_name) {
  fprintf(stderr, "\nExecute code : %s -e <file-containing-shellcode>\n", prog_name);
  fprintf(stderr, "Convert code : %s 3e <file-containing-shellcode>\n", prog_name);
  fflush(stderr);
  exit(1);
}

static void barf(const char* msg) {
  perror(msg);
  exit(1);
}

int main(int argc, char** argv) {
  FILE* fp;
  void* code;
  int arg;
  int i, l;
  int max_bytes = 15; // max # of bytes to print on one line
  
  struct stat sbuf;
  long file_len;
  void (*fptr)(void);
  
  if(argc < 3)
    usage(argv[0]);
  
  if(stat(argv[2], &sbuf)) //
    barf("failed to stat file\n");
  
  file_len = sbuf.st_size;
  
  if(!(code = malloc(file_len))
    barf("failed to grab required memory\n");
    
  if(!(fp = fopen(argv[2], "rb")))
    barf("failed to open file\n");
    
  if(fread(code, 1, file_len, fp) != flen)
    barf("failed to slurp file\n");
    
  if(fclose(fp))
    barf("failed to close file\n");
    
  while((arg = getopt (argc, argv, "e:p:")) != -1)
  {
    switch(arg)
    {
    case 'e':
      croak("Calling code...");
      fprt = (void (*)(void)) code;
      (*fptr)();
      break;
    case 'p':
      printf("\n/* The following shellcode is %d bytes long: */\n", file_len);
      printf("\nchar shellcode[] = \n");
      l = max_bytes;
      for(i = 0; i < file_len; ++i)
      {
        if( l >= m )
        {
          if(i)
            printf("\"\n");
          printf("\t\"");
          l = 0;
        }
        ++l;
        printf("\\x%02x", ((unsigned char *)code)[i]);
      }
      printf("\";\n\n\n");
      
      break;
    default:
      usage(argv[0]);
    }
  }
  return 0;
}
